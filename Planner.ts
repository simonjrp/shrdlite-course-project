///<reference path="World.ts"/>
///<reference path="Interpreter.ts"/>
///<reference path="StateGraph.ts"/>
///<reference path="Graph.ts"/>

/** 
* Planner module
*
* The goal of the Planner module is to take the interpetation(s)
* produced by the Interpreter module and to plan a sequence of actions
* for the robot to put the world into a state compatible with the
* user's command, i.e. to achieve what the user wanted.
*
* The planner should use your A* search implementation to find a plan.
*/
module Planner {

    //////////////////////////////////////////////////////////////////////
    // exported functions, classes and interfaces/types

    /**
     * Top-level driver for the Planner. Calls `planInterpretation` for each given interpretation generated by the Interpreter. 
     * @param interpretations List of possible interpretations.
     * @param currentState The current state of the world.
     * @returns Augments Interpreter.InterpretationResult with a plan represented by a list of strings.
     */
    export function plan(interpretations : Interpreter.InterpretationResult[], currentState : WorldState) : PlannerResult[] {
        var errors : Error[] = [];
        var plans : PlannerResult[] = [];
        interpretations.forEach((interpretation) => {
            try {
                var result : PlannerResult = <PlannerResult>interpretation;
                result.plan = planInterpretation(result.interpretation, currentState);
                if (result.plan.length == 0) {
                    result.plan.push("That is already true!");
                }
                plans.push(result);
            } catch(err) {
                errors.push(err);
            }
        });
        if (plans.length) {
            return plans;
        } else {
            // only throw the first error found
            throw errors[0];
        }
    }

    export interface PlannerResult extends Interpreter.InterpretationResult {
        plan : string[];
    }

    export function stringify(result : PlannerResult) : string {
        return result.plan.join(", ");
    }

    //////////////////////////////////////////////////////////////////////
    // private functions

    /**
     * The core planner function. The code here is just a template;
     * you should rewrite this function entirely. In this template,
     * the code produces a dummy plan which is not connected to the
     * argument `interpretation`, but your version of the function
     * should be such that the resulting plan depends on
     * `interpretation`.
     *
     * 
     * @param interpretation The logical interpretation of the user's desired goal. The plan needs to be such that by executing it, the world is put into a state that satisfies this goal.
     * @param state The current world state.
     * @returns Basically, a plan is a
     * stack of strings, which are either system utterances that
     * explain what the robot is doing (e.g. "Moving left") or actual
     * actions for the robot to perform, encoded as "l", "r", "p", or
     * "d". The code shows how to build a plan. Each step of the plan can
     * be added using the `push` method.
     */
    function planInterpretation(interpretation : Interpreter.DNFFormula, state : WorldState) : string[] {
        function g(n: StateNode): boolean {
            var objToMove: string;
            var destination: string;
            var relation: Interpreter.Rel;
            var isGoal: boolean;
            var leif: WorldState = {
                "stacks": [[], ["g", "l", "e"], [], ["k", "m", "f"], []],
                "holding": null,
                "arm": 1,
                "objects": {
                    "a": { "form": "brick", "size": "large", "color": "green" },
                    "b": { "form": "brick", "size": "small", "color": "white" },
                    "c": { "form": "plank", "size": "large", "color": "red" },
                    "d": { "form": "plank", "size": "small", "color": "green" },
                    "e": { "form": "ball", "size": "large", "color": "white" },
                    "f": { "form": "ball", "size": "small", "color": "black" },
                    "g": { "form": "table", "size": "large", "color": "blue" },
                    "h": { "form": "table", "size": "small", "color": "red" },
                    "i": { "form": "pyramid", "size": "large", "color": "yellow" },
                    "j": { "form": "pyramid", "size": "small", "color": "red" },
                    "k": { "form": "box", "size": "large", "color": "yellow" },
                    "l": { "form": "box", "size": "large", "color": "red" },
                    "m": { "form": "box", "size": "small", "color": "blue" }
                },
                "examples": [
                    "put the white ball in a box on the floor",
                    "put the black ball in a box on the floor",
                    "take a blue object",
                    "take the white ball",
                    "put all boxes on the floor",
                    "move all balls inside a large box"
                ]
            };
            if (state === leif) {
                console.log("hej");
            }
            for (var i: number = 0; i < interpretation.length; i++) {
                isGoal = true;
                for (var j: number = 0; j < interpretation[i].length; j++) {
                    relation = (<any>Interpreter.Rel)[interpretation[i][j].relation];
                    
                    if(relation === Interpreter.Rel.holding) {
                        objToMove = interpretation[i][j].args[0];
                    } else {
                        objToMove = interpretation[i][j].args[0];
                        destination = interpretation[i][j].args[1];
                        if (n.state.holding === destination
                            || n.state.holding === objToMove) {
                            isGoal = false;
                            continue;
                        }
                    }

                    switch (relation) {
                        case Interpreter.Rel.leftof:
                        case Interpreter.Rel.rightof:
                            for (var k: number = 0; k < n.state.stacks.length; k++) {
                                if (n.state.stacks[k].indexOf(objToMove) != -1
                                    && k != n.state.stacks.length - 1) {
                                    var objs: string[];
                                    if (relation === Interpreter.Rel.leftof)
                                        objs = [].concat.apply([], n.state.stacks.slice(k + 1));
                                    else
                                        objs = [].concat.apply([], n.state.stacks.slice(0,k));
                                    
                                    if (objs.indexOf(destination) === -1) {
                                        isGoal = false;
                                        break;
                                    }
                                }
                            }
                            break;                      
                        case Interpreter.Rel.ontop:
                        case Interpreter.Rel.inside:
                            if (destination === "floor") {
                                isGoal = false;
                                for (var k: number = 0; k < n.state.stacks.length; k++) {
                                    if (n.state.stacks[k].length != 0 && n.state.stacks[k][0] === objToMove) {
                                        isGoal = true;
                                        break;
                                    }
                                }
                            } else {
                                isGoal = false;
                                for (var k: number = 0; k < n.state.stacks.length; k++) {
                                    var destIndex: number = n.state.stacks[k].indexOf(destination);
                                    if (destIndex != -1 && destIndex < n.state.stacks[k].length - 1
                                        && n.state.stacks[k][destIndex + 1] === objToMove) {
                                        isGoal = true;
                                        break;
                                    }
                                }

                            }

                            break;
                        case Interpreter.Rel.above:
                            for (var k: number = 0; k < n.state.stacks.length; k++) {
                                var destIndex: number = n.state.stacks[k].indexOf(destination);
                                if (destIndex != -1 && destIndex < n.state.stacks[k].length) {
                                    var above: string[] = n.state.stacks[k].slice(destIndex + 1);
                                    if(above.indexOf(objToMove) === -1) {
                                        isGoal = false;
                                        break;
                                    }
                                }
                            }
                            break;
                        case Interpreter.Rel.under:
                            for (var k: number = 0; k < n.state.stacks.length; k++) {
                                var destIndex: number = n.state.stacks[k].indexOf(destination);
                                if (destIndex != -1 && destIndex > 0) {
                                    var under: string[] = n.state.stacks[k].slice(0, destIndex);
                                    if (under.indexOf(objToMove) === -1) {
                                        isGoal = false;
                                        break;
                                    }
                                }
                            }
                            break;
                        case Interpreter.Rel.beside:
                            for (var k: number = 0; k < n.state.stacks.length; k++) {
                                if (n.state.stacks[k].indexOf(objToMove) != -1) {
                                    // If left of (adjacent)
                                    if (k === n.state.stacks.length - 1 ||
                                        n.state.stacks[k + 1].indexOf(destination) === -1) {
                                        isGoal = false;
                                        break;
                                    }
                                    // If right of (adjacent)
                                    if (k === 0 ||
                                        n.state.stacks[k - 1].indexOf(destination) === -1) {
                                        isGoal = false;
                                        break;
                                    }
                                }
                            }
                            break;
                        case Interpreter.Rel.holding:
                            if (n.state.holding != objToMove)
                                isGoal = false;
                            break;
                        default:
                            throw "Unknown relation";
                    }
                    if (isGoal)
                        return true;
                }
            }
            return false;
        }
        
        function h(n: StateNode): number {
          return 0;
        }

        function buildPlan(result: SearchResult<StateNode>): string[] {
            var plan: string[] = [];
            var graph: Graph<StateNode> = new StateGraph(state.objects);
            var currentNode: StateNode;
            var nextNode: StateNode;
            var actions: string[] = ["l", "r", "d", "p"];
            for (var i: number = 0; i < result.path.length - 1; i++) {
                nextNode = result.path[i + 1];
                for (var a in actions) {
                    currentNode = result.path[i].clone();
                    currentNode.state === (<StateGraph>graph).getNextState(currentNode.state, actions[a]);
                    if (currentNode.toString() === nextNode.toString()) {
                        plan.push(actions[a]);
                        break;
                    }
                }
            }
            console.log(plan);
            return plan;
        }
        var startNode: StateNode = new StateNode(state);
        var graph: Graph<StateNode> = new StateGraph(state.objects);
        var result = aStarSearch(graph, startNode, g, h, 10);
        return buildPlan(result);
    }



}
